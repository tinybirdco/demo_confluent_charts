import * as _faker_js_faker_modules_internet from '@faker-js/faker/modules/internet';
import * as _faker_js_faker_modules_airline from '@faker-js/faker/modules/airline';
import * as _faker_js_faker from '@faker-js/faker';
import { faker } from '@faker-js/faker';
import { z } from 'zod';
import { SNSClient } from '@aws-sdk/client-sns';
import amqp from 'amqplib';

declare const extendedFaker: {
    helpers: {
        weightedRandom(items: unknown[], weights: number[]): unknown;
        normalDistribution(): number;
    };
    mockingbird: {
        latitudeNumeric: () => number;
        longitudeNumeric: () => number;
        searchEngineName(): string;
        osName(): string;
        browserName(): string;
        browserEngineName(): string;
        datetimeNow: () => string;
        datetimeRecent: () => string;
        datetimeBetween: (params: {
            start: string | number | Date;
            end: string | number | Date;
        }) => string;
        timestampNow: () => string;
        pickType: (params: {
            type: keyof typeof faker.datatype;
            length: number;
        }, opts: {
            state: Record<string, unknown>;
        } | undefined) => unknown;
        pick: (params: {
            values: unknown[];
            distribution?: "random" | "normal";
        }) => unknown;
        pickWeighted: (params: {
            values: unknown[];
            weights: number[];
        }) => unknown;
        sequentialArray: (params: {
            values: unknown[];
            iterations?: number;
        }, opts: {
            state: Record<string, unknown>;
        } | undefined) => unknown;
    };
    rawDefinitions: _faker_js_faker.LocaleDefinition;
    definitions: Readonly<{
        [x: string]: Readonly<{
            [x: string]: unknown;
        } | undefined>;
        metadata: Readonly<{
            [x: string]: unknown;
            title: string;
            code: string;
            endonym: string;
            language: string;
            variant: string;
            dir: Readonly<NonNullable<"ltr" | "rtl" | null | undefined>>;
            script: string;
            country: string;
        }>;
        airline: Readonly<{
            [x: string]: unknown;
            airline: readonly _faker_js_faker_modules_airline.Airline[];
            airplane: readonly _faker_js_faker_modules_airline.Airplane[];
            airport: readonly _faker_js_faker_modules_airline.Airport[];
        }>;
        animal: Readonly<{
            [x: string]: unknown;
            bear: readonly string[];
            bird: readonly string[];
            cat: readonly string[];
            cetacean: readonly string[];
            cow: readonly string[];
            crocodilia: readonly string[];
            dog: readonly string[];
            fish: readonly string[];
            horse: readonly string[];
            insect: readonly string[];
            lion: readonly string[];
            rabbit: readonly string[];
            rodent: readonly string[];
            snake: readonly string[];
            type: readonly string[];
        }>;
        color: Readonly<{
            [x: string]: unknown;
            human: readonly string[];
            space: readonly string[];
        }>;
        commerce: Readonly<{
            [x: string]: unknown;
            department: readonly string[];
            product_name: Readonly<_faker_js_faker.CommerceProductNameDefinition>;
            product_description: readonly string[];
        }>;
        company: Readonly<{
            [x: string]: unknown;
            buzz_adjective: readonly string[];
            buzz_noun: readonly string[];
            buzz_verb: readonly string[];
            adjective: readonly string[];
            descriptor: readonly string[];
            name_pattern: readonly string[];
            noun: readonly string[];
            suffix: readonly string[];
        }>;
        database: Readonly<{
            [x: string]: unknown;
            engine: readonly string[];
            collation: readonly string[];
            column: readonly string[];
            type: readonly string[];
        }>;
        date: Readonly<{
            [x: string]: unknown;
            month: Readonly<_faker_js_faker.DateEntryDefinition>;
            weekday: Readonly<_faker_js_faker.DateEntryDefinition>;
        }>;
        finance: Readonly<{
            [x: string]: unknown;
            account_type: readonly string[];
            credit_card: Readonly<{
                [issuer: string]: string[];
            }>;
            currency: readonly _faker_js_faker.Currency[];
            transaction_type: readonly string[];
        }>;
        hacker: Readonly<{
            [x: string]: unknown;
            abbreviation: readonly string[];
            adjective: readonly string[];
            ingverb: readonly string[];
            noun: readonly string[];
            phrase: readonly string[];
            verb: readonly string[];
        }>;
        internet: Readonly<{
            [x: string]: unknown;
            domain_suffix: readonly string[];
            example_email: readonly string[];
            free_email: readonly string[];
            emoji: Readonly<Record<_faker_js_faker_modules_internet.EmojiType, string[]>>;
            http_status_code: Readonly<Record<_faker_js_faker_modules_internet.HTTPStatusCodeType, number[]>>;
        }>;
        location: Readonly<{
            [x: string]: unknown;
            postcode_by_state: Readonly<{
                [state: string]: {
                    min: number;
                    max: number;
                };
            }>;
            postcode: Readonly<NonNullable<string | string[] | null | undefined>>;
            city_pattern: readonly string[];
            city_name: readonly string[];
            city_prefix: readonly string[];
            city_suffix: readonly string[];
            country: readonly string[];
            country_code: readonly {
                alpha2: string;
                alpha3: string;
            }[];
            state: readonly string[];
            state_abbr: readonly string[];
            county: readonly string[];
            direction: readonly string[];
            direction_abbr: readonly string[];
            building_number: readonly string[];
            street_pattern: readonly string[];
            street_name: readonly string[];
            street_prefix: readonly string[];
            street_suffix: readonly string[];
            street_address: Readonly<{
                normal: string;
                full: string;
            }>;
            secondary_address: readonly string[];
            time_zone: readonly string[];
        }>;
        lorem: Readonly<{
            [x: string]: unknown;
            words: readonly string[];
        }>;
        music: Readonly<{
            [x: string]: unknown;
            genre: readonly string[];
            song_name: readonly string[];
        }>;
        person: Readonly<{
            [x: string]: unknown;
            gender: readonly string[];
            sex: readonly string[];
            prefix: readonly string[];
            female_prefix: readonly string[];
            male_prefix: readonly string[];
            first_name: readonly string[];
            female_first_name: readonly string[];
            male_first_name: readonly string[];
            middle_name: readonly string[];
            female_middle_name: readonly string[];
            male_middle_name: readonly string[];
            last_name: readonly string[];
            female_last_name: readonly string[];
            male_last_name: readonly string[];
            suffix: readonly string[];
            name: readonly {
                value: string;
                weight: number;
            }[];
            last_name_pattern: readonly {
                value: string;
                weight: number;
            }[];
            male_last_name_pattern: readonly {
                value: string;
                weight: number;
            }[];
            female_last_name_pattern: readonly {
                value: string;
                weight: number;
            }[];
            bio_pattern: readonly string[];
            title: Readonly<{
                descriptor?: string[] | null | undefined;
                job?: string[] | null | undefined;
                level?: string[] | null | undefined;
            } & Record<string, unknown>>;
            western_zodiac_sign: readonly string[];
        }>;
        phone_number: Readonly<{
            [x: string]: unknown;
            formats: readonly string[];
        }>;
        science: Readonly<{
            [x: string]: unknown;
            unit: readonly _faker_js_faker.Unit[];
            chemicalElement: readonly _faker_js_faker.ChemicalElement[];
        }>;
        system: Readonly<{
            [x: string]: unknown;
            directoryPaths: readonly string[];
            mimeTypes: Readonly<{
                [mimeType: string]: _faker_js_faker.SystemMimeTypeEntryDefinition;
            }>;
        }>;
        vehicle: Readonly<{
            [x: string]: unknown;
            bicycle_type: readonly string[];
            fuel: readonly string[];
            manufacturer: readonly string[];
            model: readonly string[];
            type: readonly string[];
        }>;
        word: Readonly<{
            [x: string]: unknown;
            adjective: readonly string[];
            adverb: readonly string[];
            conjunction: readonly string[];
            interjection: readonly string[];
            noun: readonly string[];
            preposition: readonly string[];
            verb: readonly string[];
        }>;
    }>;
    random: _faker_js_faker.RandomModule;
    datatype: _faker_js_faker.DatatypeModule;
    airline: _faker_js_faker.AirlineModule;
    animal: _faker_js_faker.AnimalModule;
    color: _faker_js_faker.ColorModule;
    commerce: _faker_js_faker.CommerceModule;
    company: _faker_js_faker.CompanyModule;
    database: _faker_js_faker.DatabaseModule;
    date: _faker_js_faker.DateModule;
    finance: _faker_js_faker.FinanceModule;
    git: _faker_js_faker.GitModule;
    hacker: _faker_js_faker.HackerModule;
    image: _faker_js_faker.ImageModule;
    internet: _faker_js_faker.InternetModule;
    location: _faker_js_faker.AddressModule;
    lorem: _faker_js_faker.LoremModule;
    music: _faker_js_faker.MusicModule;
    person: _faker_js_faker.NameModule;
    number: _faker_js_faker.NumberModule;
    phone: _faker_js_faker.PhoneModule;
    science: _faker_js_faker.ScienceModule;
    string: _faker_js_faker.StringModule;
    system: _faker_js_faker.SystemModule;
    vehicle: _faker_js_faker.VehicleModule;
    word: _faker_js_faker.WordModule;
};

/**
 * @description Generates all possible paths of an object
 * @example extendedFaker -> "mockingbird.latitudeNumeric" | ...
 */
type ObjectPath<T extends object, D extends string = ""> = {
    [K in keyof T]: `${D}${Exclude<K, symbol>}${"" | (T[K] extends object ? ObjectPath<T[K], "."> : "")}`;
}[keyof T];
/**
 * @description Gets the type of value at certain path of an object
 * @example "mockingbird.latitudeNumeric" => () => number
 */
type ObjectAtPath<T, Path extends string> = Path extends `${infer Key}.${infer Rest}` ? Key extends keyof T ? ObjectAtPath<T[Key], Rest> : never : Path extends keyof T ? T[Path] : never;
/**
 * @description All actual faker functions, excluding utils
 */
type FakerFunctions = Omit<typeof extendedFaker, "helpers" | "locales" | "definitions">;
/**
 * @description Returns an array of parameters of a function
 * () => number => []
 */
type FakerFunctionParams<T> = T extends (...args: infer P) => any ? P extends [...args: infer P, options: {
    state: Record<string, unknown>;
}] ? P : P : never;
/**
 * @description All possible paths (functions) of extendedFaker
 */
type SchemaKey = Exclude<ObjectPath<FakerFunctions>, keyof typeof extendedFaker>;
/**
 * @description All possible paths (functions) of extendedFaker that take parameters
 */
type ParameterizedSchemaKey<K extends SchemaKey = SchemaKey> = K extends SchemaKey ? FakerFunctionParams<ObjectAtPath<FakerFunctions, K>> extends [] ? never : K : never;
/**
 * @description All possible paths (functions) of extendedFaker that do not take parameters
 */
type UnparameterizedSchemaKey = Exclude<SchemaKey, ParameterizedSchemaKey>;
/**
 * @description All possible values of a schema,
 * if the key is does not take any parameters it gets reduced to UnparameterizedSchemaKey,
 * else it will return the actual key and the parameters
 */
type SchemaValue<K extends SchemaKey = SchemaKey> = K extends UnparameterizedSchemaKey ? {
    type: UnparameterizedSchemaKey;
    count?: number;
} : {
    type: K;
    count?: number;
    params?: FakerFunctionParams<ObjectAtPath<FakerFunctions, K>>;
};
/**
 * @description The schema object
 */
type Schema = Record<string, SchemaValue>;
declare const PRESET_SCHEMA_NAMES: readonly ["Simple Example", "eCommerce Transactions", "Stock Prices", "Flight Bookings", "Content Tracking", "Web Analytics Starter Kit", "Log Analytics Starter Kit"];
type PresetSchemaName = (typeof PRESET_SCHEMA_NAMES)[number];
declare function validateSchema(schema: Schema): {
    valid: boolean;
    errors: string[];
};
type Row = Record<string, unknown | unknown[]>;

declare const presetSchemas: Record<PresetSchemaName, Schema>;

declare const baseConfigSchema: z.ZodObject<{
    schema: z.ZodEffects<z.ZodRecord<z.ZodString, z.ZodObject<{
        type: z.ZodString;
        params: z.ZodOptional<z.ZodAny>;
        count: z.ZodOptional<z.ZodNumber>;
    }, "strip", z.ZodTypeAny, {
        type: string;
        params?: any;
        count?: number | undefined;
    }, {
        type: string;
        params?: any;
        count?: number | undefined;
    }>>, Record<string, {
        type: string;
        params?: any;
        count?: number | undefined;
    }>, Record<string, {
        type: string;
        params?: any;
        count?: number | undefined;
    }>>;
    eps: z.ZodDefault<z.ZodOptional<z.ZodNumber>>;
    limit: z.ZodDefault<z.ZodOptional<z.ZodNumber>>;
    logs: z.ZodOptional<z.ZodDefault<z.ZodBoolean>>;
}, "strip", z.ZodTypeAny, {
    schema: Record<string, {
        type: string;
        params?: any;
        count?: number | undefined;
    }>;
    eps: number;
    limit: number;
    logs?: boolean | undefined;
}, {
    schema: Record<string, {
        type: string;
        params?: any;
        count?: number | undefined;
    }>;
    eps?: number | undefined;
    limit?: number | undefined;
    logs?: boolean | undefined;
}>;
type BaseConfig = z.infer<typeof baseConfigSchema>;
declare abstract class BaseGenerator<C extends BaseConfig> {
    config: C;
    private state;
    abstract sendData(data: Row[]): Promise<void>;
    constructor(config: C);
    log(level: "info" | "error", message: string): void;
    generateRow(): Row;
    generate(onMessage?: (data: Row[]) => void): Promise<void>;
}

declare const awsSNSConfigSchema: z.ZodObject<{
    schema: z.ZodEffects<z.ZodRecord<z.ZodString, z.ZodObject<{
        type: z.ZodString;
        params: z.ZodOptional<z.ZodAny>;
        count: z.ZodOptional<z.ZodNumber>;
    }, "strip", z.ZodTypeAny, {
        type: string;
        params?: any;
        count?: number | undefined;
    }, {
        type: string;
        params?: any;
        count?: number | undefined;
    }>>, Record<string, {
        type: string;
        params?: any;
        count?: number | undefined;
    }>, Record<string, {
        type: string;
        params?: any;
        count?: number | undefined;
    }>>;
    eps: z.ZodDefault<z.ZodOptional<z.ZodNumber>>;
    limit: z.ZodDefault<z.ZodOptional<z.ZodNumber>>;
    logs: z.ZodOptional<z.ZodDefault<z.ZodBoolean>>;
    region: z.ZodString;
    accessKeyId: z.ZodString;
    secretAccessKey: z.ZodString;
    topicArn: z.ZodString;
    subject: z.ZodOptional<z.ZodString>;
    snsOptions: z.ZodOptional<z.ZodAny>;
}, "strip", z.ZodTypeAny, {
    region: string;
    schema: Record<string, {
        type: string;
        params?: any;
        count?: number | undefined;
    }>;
    eps: number;
    limit: number;
    accessKeyId: string;
    secretAccessKey: string;
    topicArn: string;
    logs?: boolean | undefined;
    subject?: string | undefined;
    snsOptions?: any;
}, {
    region: string;
    schema: Record<string, {
        type: string;
        params?: any;
        count?: number | undefined;
    }>;
    accessKeyId: string;
    secretAccessKey: string;
    topicArn: string;
    eps?: number | undefined;
    limit?: number | undefined;
    logs?: boolean | undefined;
    subject?: string | undefined;
    snsOptions?: any;
}>;
type AWSSNSConfig = z.infer<typeof awsSNSConfigSchema>;
declare class AWSSNSGenerator extends BaseGenerator<AWSSNSConfig> {
    readonly client: SNSClient;
    constructor(config: AWSSNSConfig);
    sendData(rows: Row[]): Promise<void>;
}

declare const ablyConfigSchema: z.ZodObject<{
    schema: z.ZodEffects<z.ZodRecord<z.ZodString, z.ZodObject<{
        type: z.ZodString;
        params: z.ZodOptional<z.ZodAny>;
        count: z.ZodOptional<z.ZodNumber>;
    }, "strip", z.ZodTypeAny, {
        type: string;
        params?: any;
        count?: number | undefined;
    }, {
        type: string;
        params?: any;
        count?: number | undefined;
    }>>, Record<string, {
        type: string;
        params?: any;
        count?: number | undefined;
    }>, Record<string, {
        type: string;
        params?: any;
        count?: number | undefined;
    }>>;
    eps: z.ZodDefault<z.ZodOptional<z.ZodNumber>>;
    limit: z.ZodDefault<z.ZodOptional<z.ZodNumber>>;
    logs: z.ZodOptional<z.ZodDefault<z.ZodBoolean>>;
    apiKey: z.ZodString;
    channelId: z.ZodString;
}, "strip", z.ZodTypeAny, {
    schema: Record<string, {
        type: string;
        params?: any;
        count?: number | undefined;
    }>;
    eps: number;
    limit: number;
    apiKey: string;
    channelId: string;
    logs?: boolean | undefined;
}, {
    schema: Record<string, {
        type: string;
        params?: any;
        count?: number | undefined;
    }>;
    apiKey: string;
    channelId: string;
    eps?: number | undefined;
    limit?: number | undefined;
    logs?: boolean | undefined;
}>;
type AblyConfig = z.infer<typeof ablyConfigSchema>;
declare class AblyGenerator extends BaseGenerator<AblyConfig> {
    readonly token: string;
    constructor(config: AblyConfig);
    sendData(rows: Row[]): Promise<void>;
}

declare const confluentCloudKafkaConfigSchema: z.ZodObject<{
    schema: z.ZodEffects<z.ZodRecord<z.ZodString, z.ZodObject<{
        type: z.ZodString;
        params: z.ZodOptional<z.ZodAny>;
        count: z.ZodOptional<z.ZodNumber>;
    }, "strip", z.ZodTypeAny, {
        type: string;
        params?: any;
        count?: number | undefined;
    }, {
        type: string;
        params?: any;
        count?: number | undefined;
    }>>, Record<string, {
        type: string;
        params?: any;
        count?: number | undefined;
    }>, Record<string, {
        type: string;
        params?: any;
        count?: number | undefined;
    }>>;
    eps: z.ZodDefault<z.ZodOptional<z.ZodNumber>>;
    limit: z.ZodDefault<z.ZodOptional<z.ZodNumber>>;
    logs: z.ZodOptional<z.ZodDefault<z.ZodBoolean>>;
    restEndpoint: z.ZodString;
    clusterId: z.ZodString;
    topic: z.ZodString;
    apiKey: z.ZodString;
    apiSecret: z.ZodString;
    headers: z.ZodOptional<z.ZodArray<z.ZodRecord<z.ZodString, z.ZodString>, "many">>;
    key: z.ZodOptional<z.ZodUnion<[z.ZodObject<{
        type: z.ZodLiteral<"BINARY">;
        data: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        type: "BINARY";
        data: string;
    }, {
        type: "BINARY";
        data: string;
    }>, z.ZodObject<{
        type: z.ZodLiteral<"JSON">;
        data: z.ZodRecord<z.ZodString, z.ZodString>;
    }, "strip", z.ZodTypeAny, {
        type: "JSON";
        data: Record<string, string>;
    }, {
        type: "JSON";
        data: Record<string, string>;
    }>]>>;
}, "strip", z.ZodTypeAny, {
    schema: Record<string, {
        type: string;
        params?: any;
        count?: number | undefined;
    }>;
    eps: number;
    limit: number;
    apiKey: string;
    restEndpoint: string;
    clusterId: string;
    topic: string;
    apiSecret: string;
    logs?: boolean | undefined;
    headers?: Record<string, string>[] | undefined;
    key?: {
        type: "BINARY";
        data: string;
    } | {
        type: "JSON";
        data: Record<string, string>;
    } | undefined;
}, {
    schema: Record<string, {
        type: string;
        params?: any;
        count?: number | undefined;
    }>;
    apiKey: string;
    restEndpoint: string;
    clusterId: string;
    topic: string;
    apiSecret: string;
    eps?: number | undefined;
    limit?: number | undefined;
    logs?: boolean | undefined;
    headers?: Record<string, string>[] | undefined;
    key?: {
        type: "BINARY";
        data: string;
    } | {
        type: "JSON";
        data: Record<string, string>;
    } | undefined;
}>;
type ConfluentCloudKafkaConfig = z.infer<typeof confluentCloudKafkaConfigSchema>;
declare class ConfluentCloudKafkaGenerator extends BaseGenerator<ConfluentCloudKafkaConfig> {
    readonly token: string;
    constructor(config: ConfluentCloudKafkaConfig);
    sendData(rows: Row[]): Promise<void>;
}

declare class LogGenerator extends BaseGenerator<BaseConfig> {
    constructor(config: BaseConfig);
    sendData(rows: Row[]): Promise<void>;
}

declare const rabbitmqConfigSchema: z.ZodObject<{
    schema: z.ZodEffects<z.ZodRecord<z.ZodString, z.ZodObject<{
        type: z.ZodString;
        params: z.ZodOptional<z.ZodAny>;
        count: z.ZodOptional<z.ZodNumber>;
    }, "strip", z.ZodTypeAny, {
        type: string;
        params?: any;
        count?: number | undefined;
    }, {
        type: string;
        params?: any;
        count?: number | undefined;
    }>>, Record<string, {
        type: string;
        params?: any;
        count?: number | undefined;
    }>, Record<string, {
        type: string;
        params?: any;
        count?: number | undefined;
    }>>;
    eps: z.ZodDefault<z.ZodOptional<z.ZodNumber>>;
    limit: z.ZodDefault<z.ZodOptional<z.ZodNumber>>;
    logs: z.ZodOptional<z.ZodDefault<z.ZodBoolean>>;
    endpoint: z.ZodString;
    queue: z.ZodString;
    assertQueueOptions: z.ZodOptional<z.ZodObject<{
        exclusive: z.ZodOptional<z.ZodBoolean>;
        durable: z.ZodOptional<z.ZodBoolean>;
        autoDelete: z.ZodOptional<z.ZodBoolean>;
        arguments: z.ZodOptional<z.ZodAny>;
        messageTtl: z.ZodOptional<z.ZodNumber>;
        expires: z.ZodOptional<z.ZodNumber>;
        deadLetterExchange: z.ZodOptional<z.ZodString>;
        deadLetterRoutingKey: z.ZodOptional<z.ZodString>;
        maxLength: z.ZodOptional<z.ZodNumber>;
        maxPriority: z.ZodOptional<z.ZodNumber>;
    }, "strip", z.ZodTypeAny, {
        exclusive?: boolean | undefined;
        durable?: boolean | undefined;
        autoDelete?: boolean | undefined;
        arguments?: any;
        messageTtl?: number | undefined;
        expires?: number | undefined;
        deadLetterExchange?: string | undefined;
        deadLetterRoutingKey?: string | undefined;
        maxLength?: number | undefined;
        maxPriority?: number | undefined;
    }, {
        exclusive?: boolean | undefined;
        durable?: boolean | undefined;
        autoDelete?: boolean | undefined;
        arguments?: any;
        messageTtl?: number | undefined;
        expires?: number | undefined;
        deadLetterExchange?: string | undefined;
        deadLetterRoutingKey?: string | undefined;
        maxLength?: number | undefined;
        maxPriority?: number | undefined;
    }>>;
    publishOptions: z.ZodOptional<z.ZodObject<{
        expiration: z.ZodOptional<z.ZodUnion<[z.ZodString, z.ZodNumber]>>;
        userId: z.ZodOptional<z.ZodString>;
        CC: z.ZodOptional<z.ZodUnion<[z.ZodString, z.ZodArray<z.ZodString, "many">]>>;
        mandatory: z.ZodOptional<z.ZodBoolean>;
        persistent: z.ZodOptional<z.ZodBoolean>;
        deliveryMode: z.ZodOptional<z.ZodUnion<[z.ZodBoolean, z.ZodNumber]>>;
        BCC: z.ZodOptional<z.ZodUnion<[z.ZodString, z.ZodArray<z.ZodString, "many">]>>;
        contentType: z.ZodOptional<z.ZodString>;
        contentEncoding: z.ZodOptional<z.ZodString>;
        headers: z.ZodOptional<z.ZodAny>;
        priority: z.ZodOptional<z.ZodNumber>;
        correlationId: z.ZodOptional<z.ZodString>;
        replyTo: z.ZodOptional<z.ZodString>;
        messageId: z.ZodOptional<z.ZodString>;
        timestamp: z.ZodOptional<z.ZodNumber>;
        type: z.ZodOptional<z.ZodString>;
        appId: z.ZodOptional<z.ZodString>;
    }, "strip", z.ZodTypeAny, {
        expiration?: string | number | undefined;
        userId?: string | undefined;
        CC?: string | string[] | undefined;
        mandatory?: boolean | undefined;
        persistent?: boolean | undefined;
        deliveryMode?: number | boolean | undefined;
        BCC?: string | string[] | undefined;
        contentType?: string | undefined;
        contentEncoding?: string | undefined;
        headers?: any;
        priority?: number | undefined;
        correlationId?: string | undefined;
        replyTo?: string | undefined;
        messageId?: string | undefined;
        timestamp?: number | undefined;
        type?: string | undefined;
        appId?: string | undefined;
    }, {
        expiration?: string | number | undefined;
        userId?: string | undefined;
        CC?: string | string[] | undefined;
        mandatory?: boolean | undefined;
        persistent?: boolean | undefined;
        deliveryMode?: number | boolean | undefined;
        BCC?: string | string[] | undefined;
        contentType?: string | undefined;
        contentEncoding?: string | undefined;
        headers?: any;
        priority?: number | undefined;
        correlationId?: string | undefined;
        replyTo?: string | undefined;
        messageId?: string | undefined;
        timestamp?: number | undefined;
        type?: string | undefined;
        appId?: string | undefined;
    }>>;
}, "strip", z.ZodTypeAny, {
    schema: Record<string, {
        type: string;
        params?: any;
        count?: number | undefined;
    }>;
    eps: number;
    limit: number;
    endpoint: string;
    queue: string;
    logs?: boolean | undefined;
    assertQueueOptions?: {
        exclusive?: boolean | undefined;
        durable?: boolean | undefined;
        autoDelete?: boolean | undefined;
        arguments?: any;
        messageTtl?: number | undefined;
        expires?: number | undefined;
        deadLetterExchange?: string | undefined;
        deadLetterRoutingKey?: string | undefined;
        maxLength?: number | undefined;
        maxPriority?: number | undefined;
    } | undefined;
    publishOptions?: {
        expiration?: string | number | undefined;
        userId?: string | undefined;
        CC?: string | string[] | undefined;
        mandatory?: boolean | undefined;
        persistent?: boolean | undefined;
        deliveryMode?: number | boolean | undefined;
        BCC?: string | string[] | undefined;
        contentType?: string | undefined;
        contentEncoding?: string | undefined;
        headers?: any;
        priority?: number | undefined;
        correlationId?: string | undefined;
        replyTo?: string | undefined;
        messageId?: string | undefined;
        timestamp?: number | undefined;
        type?: string | undefined;
        appId?: string | undefined;
    } | undefined;
}, {
    schema: Record<string, {
        type: string;
        params?: any;
        count?: number | undefined;
    }>;
    endpoint: string;
    queue: string;
    eps?: number | undefined;
    limit?: number | undefined;
    logs?: boolean | undefined;
    assertQueueOptions?: {
        exclusive?: boolean | undefined;
        durable?: boolean | undefined;
        autoDelete?: boolean | undefined;
        arguments?: any;
        messageTtl?: number | undefined;
        expires?: number | undefined;
        deadLetterExchange?: string | undefined;
        deadLetterRoutingKey?: string | undefined;
        maxLength?: number | undefined;
        maxPriority?: number | undefined;
    } | undefined;
    publishOptions?: {
        expiration?: string | number | undefined;
        userId?: string | undefined;
        CC?: string | string[] | undefined;
        mandatory?: boolean | undefined;
        persistent?: boolean | undefined;
        deliveryMode?: number | boolean | undefined;
        BCC?: string | string[] | undefined;
        contentType?: string | undefined;
        contentEncoding?: string | undefined;
        headers?: any;
        priority?: number | undefined;
        correlationId?: string | undefined;
        replyTo?: string | undefined;
        messageId?: string | undefined;
        timestamp?: number | undefined;
        type?: string | undefined;
        appId?: string | undefined;
    } | undefined;
}>;
type RabbitMQConfig = z.infer<typeof rabbitmqConfigSchema>;
declare class RabbitMQGenerator extends BaseGenerator<RabbitMQConfig> {
    connection: amqp.Connection | undefined;
    constructor(config: RabbitMQConfig);
    sendData(rows: Row[]): Promise<void>;
}

declare const tinybirdConfigSchema: z.ZodObject<{
    schema: z.ZodEffects<z.ZodRecord<z.ZodString, z.ZodObject<{
        type: z.ZodString;
        params: z.ZodOptional<z.ZodAny>;
        count: z.ZodOptional<z.ZodNumber>;
    }, "strip", z.ZodTypeAny, {
        type: string;
        params?: any;
        count?: number | undefined;
    }, {
        type: string;
        params?: any;
        count?: number | undefined;
    }>>, Record<string, {
        type: string;
        params?: any;
        count?: number | undefined;
    }>, Record<string, {
        type: string;
        params?: any;
        count?: number | undefined;
    }>>;
    eps: z.ZodDefault<z.ZodOptional<z.ZodNumber>>;
    limit: z.ZodDefault<z.ZodOptional<z.ZodNumber>>;
    logs: z.ZodOptional<z.ZodDefault<z.ZodBoolean>>;
    endpoint: z.ZodString;
    datasource: z.ZodString;
    token: z.ZodString;
}, "strip", z.ZodTypeAny, {
    schema: Record<string, {
        type: string;
        params?: any;
        count?: number | undefined;
    }>;
    eps: number;
    limit: number;
    endpoint: string;
    datasource: string;
    token: string;
    logs?: boolean | undefined;
}, {
    schema: Record<string, {
        type: string;
        params?: any;
        count?: number | undefined;
    }>;
    endpoint: string;
    datasource: string;
    token: string;
    eps?: number | undefined;
    limit?: number | undefined;
    logs?: boolean | undefined;
}>;
type TinybirdConfig = z.infer<typeof tinybirdConfigSchema>;
declare class TinybirdGenerator extends BaseGenerator<TinybirdConfig> {
    readonly endpoints: {
        readonly eu_gcp: "https://api.tinybird.co";
        readonly us_gcp: "https://api.us-east.tinybird.co";
    };
    readonly events_path: "/v0/events";
    constructor(config: TinybirdConfig);
    sendData(rows: Row[]): Promise<void>;
}

declare const upstashKafkaConfigSchema: z.ZodObject<{
    schema: z.ZodEffects<z.ZodRecord<z.ZodString, z.ZodObject<{
        type: z.ZodString;
        params: z.ZodOptional<z.ZodAny>;
        count: z.ZodOptional<z.ZodNumber>;
    }, "strip", z.ZodTypeAny, {
        type: string;
        params?: any;
        count?: number | undefined;
    }, {
        type: string;
        params?: any;
        count?: number | undefined;
    }>>, Record<string, {
        type: string;
        params?: any;
        count?: number | undefined;
    }>, Record<string, {
        type: string;
        params?: any;
        count?: number | undefined;
    }>>;
    eps: z.ZodDefault<z.ZodOptional<z.ZodNumber>>;
    limit: z.ZodDefault<z.ZodOptional<z.ZodNumber>>;
    logs: z.ZodOptional<z.ZodDefault<z.ZodBoolean>>;
    address: z.ZodString;
    user: z.ZodString;
    pass: z.ZodString;
    topic: z.ZodString;
}, "strip", z.ZodTypeAny, {
    schema: Record<string, {
        type: string;
        params?: any;
        count?: number | undefined;
    }>;
    eps: number;
    limit: number;
    topic: string;
    address: string;
    user: string;
    pass: string;
    logs?: boolean | undefined;
}, {
    schema: Record<string, {
        type: string;
        params?: any;
        count?: number | undefined;
    }>;
    topic: string;
    address: string;
    user: string;
    pass: string;
    eps?: number | undefined;
    limit?: number | undefined;
    logs?: boolean | undefined;
}>;
type UpstashKafkaConfig = z.infer<typeof upstashKafkaConfigSchema>;
declare class UpstashKafkaGenerator extends BaseGenerator<UpstashKafkaConfig> {
    readonly auth: string;
    constructor(config: UpstashKafkaConfig);
    sendData(rows: Row[]): Promise<void>;
}

type MockingbirdGenerator = InstanceType<typeof BaseGenerator>;

export { AWSSNSConfig, AWSSNSGenerator, AblyConfig, AblyGenerator, BaseConfig, BaseGenerator, ConfluentCloudKafkaConfig, ConfluentCloudKafkaGenerator, FakerFunctionParams, FakerFunctions, LogGenerator, MockingbirdGenerator, PRESET_SCHEMA_NAMES, ParameterizedSchemaKey, PresetSchemaName, RabbitMQConfig, RabbitMQGenerator, Row, Schema, SchemaKey, SchemaValue, TinybirdConfig, TinybirdGenerator, UnparameterizedSchemaKey, UpstashKafkaConfig, UpstashKafkaGenerator, presetSchemas, validateSchema };
